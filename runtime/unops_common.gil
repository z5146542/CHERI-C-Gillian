#internal

proc i__unops_negb (val) {
       goto [ l-nth(val, 1i) = 0i ] ctn utd;
  ctn: ret := {{ "int32", 1i }};
       return;
  utd: ret := {{ "int32", 0i }};
       return
};

proc i__unops_bitwisenot (tval) {
      typ := l-nth(tval, 0i);
       val := l-nth(tval, 1i);
       goto [ typ = "uint8"  ] u8 t2;
  t2:  goto [ typ = "int8"   ] i8 t3;
  t3:  goto [ typ = "uint16" ] u16 t4;
  t4:  goto [ typ = "int16"  ] i16 t5;
  t5:  goto [ typ = "uint32" ] u32 t6;
  t6:  goto [ typ = "int32"  ] i32 t7;
  t7:  goto [ typ = "uint64" ] u64 t8;
  t8:  goto [ typ = "int64"  ] i64 fl;
  u8:  ret := {{ typ, 255i i- val }};
  i8:  goto end;
  u16: ret := {{ typ, 65535i i- val }};
       return;
  i16: goto end;
  u32: ret := {{ typ, 4294967295 i- val }};
       return;
  i32: goto end;
  u64: ret := {{ typ, 18446744073709551615i i- val }};
       return;
  i64: goto end;
  end: fail [operator] ("haven't implemented ~ for signed int");
  fl:  fail [operator] ("cannot bitnot non-int type")
};

proc i__unops_neg (tval) {
  typ := l-nth(tval, 0i);
  goto [ typ = "uint32" ] us s;
  s: val := l-nth(tval, 1i);
  nval := 0i i- val;
  ret := {{ typ, nval }};
  return;
  us: fail [operator] ("cannot negate value: must be signed int")
};

(** casting involves three processes:
  * 1. Casting capabilities: "i__unops_cast"(ni, cap);
  *    Casting capabilities changes the cap "offsiz" value
  * 2. Casting primitive values: "i__unops_cast"("type", value)
  *    Casting values internally calls [cast_val].
  * 3. Casting anything to _Bool: "i__unops_cast"("_Bool", value);
  *    needed for assert(a);
  *)
proc i__unops_cast (typ, val) {
       (* case 1 *)
       goto [ typeOf(typ) = Int ] nct tptr;
 tptr: goto [ typ = "_Bool" ] bct nptr;
  bct: asdf := "i__is_cap"(val);
       goto [ asdf ] t1 t2;
       (* case 3 *)
   t1: tmp := [NULL]();
       ret := "i__binops_cmp_neq"(val, tmp);
       return;
   t2: ret := "i__binops_cmp_neq"(val, {{ l-nth(val, 0i), 0i }});
       return;
  nct: ptrt := "i__is_cap"(val);
       goto [ ptrt ] pend feil;
 pend: ret := {{ l-nth(val, 0i), l-nth(val, 1i), l-nth(val, 2i), l-nth(val, 3i), 
                 l-nth(val, 4i), l-nth(val, 5i), l-nth(val, 6i), l-nth(val, 7i), 
                 l-nth(val, 8i), l-nth(val, 9i), l-nth(val, 10i), typ }};
       return;
       (* case 2 *)
 nptr: goto [ typeOf(typ) = Str ] tval feil;
 tval: ret := [cast_val](typ, val);
       return;
 feil: fail[comparison]("Cast not supported or invalid arg")
};

proc i__is_cap (cap) {
       goto [ l-len(cap) = 12i ] nxt utd;
  nxt: goto [( (typeOf(l-nth(cap, 0i)) = Obj) and
               (typeOf(l-nth(cap, 1i)) = Int) and
               (typeOf(l-nth(cap, 2i)) = Int) and
               (typeOf(l-nth(cap, 3i)) = Int) and
               (typeOf(l-nth(cap, 4i)) = Bool) and
               (typeOf(l-nth(cap, 5i)) = Bool) and
               (typeOf(l-nth(cap, 6i)) = Bool) and
               (typeOf(l-nth(cap, 7i)) = Bool) and
               (typeOf(l-nth(cap, 8i)) = Bool) and
               (typeOf(l-nth(cap, 9i)) = Bool) and
               (typeOf(l-nth(cap, 10i)) = Bool) and
               (typeOf(l-nth(cap, 11i)) = Int) )] ctn utd;
  ctn: ret := true;
       return;
  utd: ret := false;
       return
};

proc i__is_addr (pair) {
       goto [ l-len(pair) = 2i ] nxt utd;
  nxt: goto [( (typeOf(l-nth(pair, 0i)) = Obj) and
               (typeOf(l-nth(pair, 1i)) = Int) )] ctn utd;
  ctn: ret := true;
       return;
  utd: ret := false;
       return
};
